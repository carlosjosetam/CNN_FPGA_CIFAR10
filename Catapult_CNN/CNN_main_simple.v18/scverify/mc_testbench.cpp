// ----------------------------------------------------------------------------
// SystemC Testbench Body
//
//    HLS version: 10.1b/747384 Production Release
//       HLS date: Wed Nov  1 10:26:06 PDT 2017
//  Flow Packages: HDL_Tcl 8.0a, SCVerify 8.0a
//
//   Generated by: xph3sei710@ocaepc56
// Generated date: Fri Jan 25 10:40:03 CET 2019
//
// ----------------------------------------------------------------------------
// 
// -------------------------------------
// testbench
// User supplied testbench
// -------------------------------------
// 
#include "mc_testbench.h"
#include <mc_testbench_util.h>
#include <mc_simulator_extensions.h>

testbench* testbench::that;
bool testbench::enable_idle_sync_mode;
unsigned short testbench::idle_sync_stable_cycles;
bool testbench::image_ignore;
bool testbench::image_skip;
bool testbench::image_skip_quiet;
bool testbench::image_skip_once;
bool testbench::image_skip_noerr;
void mc_testbench_image_skip(bool v) { testbench::image_skip = v; }
int testbench::image_array_comp_first;
int testbench::image_array_comp_last;
mc_wait_ctrl testbench::image_wait_ctrl;
bool testbench::F_1_ignore;
bool testbench::F_1_skip;
bool testbench::F_1_skip_quiet;
bool testbench::F_1_skip_once;
bool testbench::F_1_skip_noerr;
void mc_testbench_F_1_skip(bool v) { testbench::F_1_skip = v; }
int testbench::F_1_array_comp_first;
int testbench::F_1_array_comp_last;
mc_wait_ctrl testbench::F_1_wait_ctrl;
bool testbench::B_1_ignore;
bool testbench::B_1_skip;
bool testbench::B_1_skip_quiet;
bool testbench::B_1_skip_once;
bool testbench::B_1_skip_noerr;
void mc_testbench_B_1_skip(bool v) { testbench::B_1_skip = v; }
int testbench::B_1_array_comp_first;
int testbench::B_1_array_comp_last;
mc_wait_ctrl testbench::B_1_wait_ctrl;
bool testbench::F_2_ignore;
bool testbench::F_2_skip;
bool testbench::F_2_skip_quiet;
bool testbench::F_2_skip_once;
bool testbench::F_2_skip_noerr;
void mc_testbench_F_2_skip(bool v) { testbench::F_2_skip = v; }
int testbench::F_2_array_comp_first;
int testbench::F_2_array_comp_last;
mc_wait_ctrl testbench::F_2_wait_ctrl;
bool testbench::B_2_ignore;
bool testbench::B_2_skip;
bool testbench::B_2_skip_quiet;
bool testbench::B_2_skip_once;
bool testbench::B_2_skip_noerr;
void mc_testbench_B_2_skip(bool v) { testbench::B_2_skip = v; }
int testbench::B_2_array_comp_first;
int testbench::B_2_array_comp_last;
mc_wait_ctrl testbench::B_2_wait_ctrl;
bool testbench::F_3_ignore;
bool testbench::F_3_skip;
bool testbench::F_3_skip_quiet;
bool testbench::F_3_skip_once;
bool testbench::F_3_skip_noerr;
void mc_testbench_F_3_skip(bool v) { testbench::F_3_skip = v; }
int testbench::F_3_array_comp_first;
int testbench::F_3_array_comp_last;
mc_wait_ctrl testbench::F_3_wait_ctrl;
bool testbench::B_3_ignore;
bool testbench::B_3_skip;
bool testbench::B_3_skip_quiet;
bool testbench::B_3_skip_once;
bool testbench::B_3_skip_noerr;
void mc_testbench_B_3_skip(bool v) { testbench::B_3_skip = v; }
int testbench::B_3_array_comp_first;
int testbench::B_3_array_comp_last;
mc_wait_ctrl testbench::B_3_wait_ctrl;
bool testbench::P_W_ignore;
bool testbench::P_W_skip;
bool testbench::P_W_skip_quiet;
bool testbench::P_W_skip_once;
bool testbench::P_W_skip_noerr;
void mc_testbench_P_W_skip(bool v) { testbench::P_W_skip = v; }
int testbench::P_W_array_comp_first;
int testbench::P_W_array_comp_last;
mc_wait_ctrl testbench::P_W_wait_ctrl;
bool testbench::P_B_ignore;
bool testbench::P_B_skip;
bool testbench::P_B_skip_quiet;
bool testbench::P_B_skip_once;
bool testbench::P_B_skip_noerr;
void mc_testbench_P_B_skip(bool v) { testbench::P_B_skip = v; }
int testbench::P_B_array_comp_first;
int testbench::P_B_array_comp_last;
mc_wait_ctrl testbench::P_B_wait_ctrl;
bool testbench::index_ignore;
bool testbench::index_skip;
bool testbench::index_skip_quiet;
bool testbench::index_skip_once;
bool testbench::index_skip_noerr;
void mc_testbench_index_skip(bool v) { testbench::index_skip = v; }
int testbench::index_array_comp_first;
int testbench::index_array_comp_last;
bool testbench::index_use_mask;
ac_int<4, false > testbench::index_output_mask;
mc_wait_ctrl testbench::index_wait_ctrl;
#ifndef CCS_SCVERIFY_USE_CCS_BLOCK
extern "C++" void CNN_main_simple( ac_fixed<16, 4, true, AC_TRN, AC_SAT > image[1728],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > F_1[1728],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > B_1[64],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > F_2[18432],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > B_2[32],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > F_3[5760],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > B_3[20],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > P_W[1800],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > P_B[10],  ac_int<4, false > index[1]);
#endif

// ============================================
// Function: wait_for_idle_sync
// --------------------------------------------

void testbench::wait_for_idle_sync()
{
   if (enable_idle_sync_mode) {
      std::cout << "mc_testbench STOPPING   @ " << sc_time_stamp() << std::endl;
      that->cpp_testbench_active.write(false);
      while (that->design_is_idle.read())  that->wait(that->design_is_idle.value_changed_event());
      while (!that->design_is_idle.read()) that->wait(that->design_is_idle.value_changed_event());
      that->cpp_testbench_active.write(true);
      std::cout << "mc_testbench CONTINUING @ " << sc_time_stamp() << std::endl;
   } else {
      that->cpp_testbench_active.write(true);
   }
}
// ============================================
// Function: set_enable_stalls
// --------------------------------------------

void testbench::set_enable_stalls(bool flag)
{
   if (flag) {
     std::cout << "Enabling STALL_FLAG toggling" << std::endl;
     that->enable_stalls.write(sc_dt::Log_1);
   } else {
     std::cout << "Disabling STALL_FLAG toggling" << std::endl;
     that->enable_stalls.write(sc_dt::Log_0);
   }
}
// ============================================
// Function: capture_image
// --------------------------------------------

void testbench::capture_image( ac_fixed<16, 4, true, AC_TRN, AC_SAT > image[1728])
{
   if (image_capture_count == wait_cnt)
      wait_on_input_required();
   if (_capture_image && !image_ignore)
   {
      int cur_iter = image_iteration_count;
      ++image_iteration_count;
      mgc_sysc_ver_array1D<ac_fixed<16, 4, true, AC_TRN, AC_SAT >,1728> image_tmp;
      int image_linear_idx = 0;
      for (int image_idx_0 = 0; image_idx_0 < 1728; ++image_idx_0)
         image_tmp[image_linear_idx++] = image[image_idx_0];
      ccs_image->put(image_tmp);
      ++image_capture_count;
      mc_testbench::process_wait_ctrl("image",image_wait_ctrl,ccs_wait_ctrl_image.operator->(),cur_iter,image_capture_count,0);
   }
   image_ignore = false;
}
// ============================================
// Function: capture_F_1
// --------------------------------------------

void testbench::capture_F_1( ac_fixed<16, 4, true, AC_TRN, AC_SAT > F_1[1728])
{
   if (F_1_capture_count == wait_cnt)
      wait_on_input_required();
   if (_capture_F_1 && !F_1_ignore)
   {
      int cur_iter = F_1_iteration_count;
      ++F_1_iteration_count;
      mgc_sysc_ver_array1D<ac_fixed<16, 4, true, AC_TRN, AC_SAT >,1728> F_1_tmp;
      int F_1_linear_idx = 0;
      for (int F_1_idx_0 = 0; F_1_idx_0 < 1728; ++F_1_idx_0)
         F_1_tmp[F_1_linear_idx++] = F_1[F_1_idx_0];
      ccs_F_1->put(F_1_tmp);
      ++F_1_capture_count;
      mc_testbench::process_wait_ctrl("F_1",F_1_wait_ctrl,ccs_wait_ctrl_F_1.operator->(),cur_iter,F_1_capture_count,0);
   }
   F_1_ignore = false;
}
// ============================================
// Function: capture_B_1
// --------------------------------------------

void testbench::capture_B_1( ac_fixed<16, 4, true, AC_TRN, AC_SAT > B_1[64])
{
   if (B_1_capture_count == wait_cnt)
      wait_on_input_required();
   if (_capture_B_1 && !B_1_ignore)
   {
      int cur_iter = B_1_iteration_count;
      ++B_1_iteration_count;
      mgc_sysc_ver_array1D<ac_fixed<16, 4, true, AC_TRN, AC_SAT >,64> B_1_tmp;
      int B_1_linear_idx = 0;
      for (int B_1_idx_0 = 0; B_1_idx_0 < 64; ++B_1_idx_0)
         B_1_tmp[B_1_linear_idx++] = B_1[B_1_idx_0];
      ccs_B_1->put(B_1_tmp);
      ++B_1_capture_count;
      mc_testbench::process_wait_ctrl("B_1",B_1_wait_ctrl,ccs_wait_ctrl_B_1.operator->(),cur_iter,B_1_capture_count,0);
   }
   B_1_ignore = false;
}
// ============================================
// Function: capture_F_2
// --------------------------------------------

void testbench::capture_F_2( ac_fixed<16, 4, true, AC_TRN, AC_SAT > F_2[18432])
{
   if (F_2_capture_count == wait_cnt)
      wait_on_input_required();
   if (_capture_F_2 && !F_2_ignore)
   {
      int cur_iter = F_2_iteration_count;
      ++F_2_iteration_count;
      mgc_sysc_ver_array1D<ac_fixed<16, 4, true, AC_TRN, AC_SAT >,18432> F_2_tmp;
      int F_2_linear_idx = 0;
      for (int F_2_idx_0 = 0; F_2_idx_0 < 18432; ++F_2_idx_0)
         F_2_tmp[F_2_linear_idx++] = F_2[F_2_idx_0];
      ccs_F_2->put(F_2_tmp);
      ++F_2_capture_count;
      mc_testbench::process_wait_ctrl("F_2",F_2_wait_ctrl,ccs_wait_ctrl_F_2.operator->(),cur_iter,F_2_capture_count,0);
   }
   F_2_ignore = false;
}
// ============================================
// Function: capture_B_2
// --------------------------------------------

void testbench::capture_B_2( ac_fixed<16, 4, true, AC_TRN, AC_SAT > B_2[32])
{
   if (B_2_capture_count == wait_cnt)
      wait_on_input_required();
   if (_capture_B_2 && !B_2_ignore)
   {
      int cur_iter = B_2_iteration_count;
      ++B_2_iteration_count;
      mgc_sysc_ver_array1D<ac_fixed<16, 4, true, AC_TRN, AC_SAT >,32> B_2_tmp;
      int B_2_linear_idx = 0;
      for (int B_2_idx_0 = 0; B_2_idx_0 < 32; ++B_2_idx_0)
         B_2_tmp[B_2_linear_idx++] = B_2[B_2_idx_0];
      ccs_B_2->put(B_2_tmp);
      ++B_2_capture_count;
      mc_testbench::process_wait_ctrl("B_2",B_2_wait_ctrl,ccs_wait_ctrl_B_2.operator->(),cur_iter,B_2_capture_count,0);
   }
   B_2_ignore = false;
}
// ============================================
// Function: capture_F_3
// --------------------------------------------

void testbench::capture_F_3( ac_fixed<16, 4, true, AC_TRN, AC_SAT > F_3[5760])
{
   if (F_3_capture_count == wait_cnt)
      wait_on_input_required();
   if (_capture_F_3 && !F_3_ignore)
   {
      int cur_iter = F_3_iteration_count;
      ++F_3_iteration_count;
      mgc_sysc_ver_array1D<ac_fixed<16, 4, true, AC_TRN, AC_SAT >,5760> F_3_tmp;
      int F_3_linear_idx = 0;
      for (int F_3_idx_0 = 0; F_3_idx_0 < 5760; ++F_3_idx_0)
         F_3_tmp[F_3_linear_idx++] = F_3[F_3_idx_0];
      ccs_F_3->put(F_3_tmp);
      ++F_3_capture_count;
      mc_testbench::process_wait_ctrl("F_3",F_3_wait_ctrl,ccs_wait_ctrl_F_3.operator->(),cur_iter,F_3_capture_count,0);
   }
   F_3_ignore = false;
}
// ============================================
// Function: capture_B_3
// --------------------------------------------

void testbench::capture_B_3( ac_fixed<16, 4, true, AC_TRN, AC_SAT > B_3[20])
{
   if (B_3_capture_count == wait_cnt)
      wait_on_input_required();
   if (_capture_B_3 && !B_3_ignore)
   {
      int cur_iter = B_3_iteration_count;
      ++B_3_iteration_count;
      mgc_sysc_ver_array1D<ac_fixed<16, 4, true, AC_TRN, AC_SAT >,20> B_3_tmp;
      int B_3_linear_idx = 0;
      for (int B_3_idx_0 = 0; B_3_idx_0 < 20; ++B_3_idx_0)
         B_3_tmp[B_3_linear_idx++] = B_3[B_3_idx_0];
      ccs_B_3->put(B_3_tmp);
      ++B_3_capture_count;
      mc_testbench::process_wait_ctrl("B_3",B_3_wait_ctrl,ccs_wait_ctrl_B_3.operator->(),cur_iter,B_3_capture_count,0);
   }
   B_3_ignore = false;
}
// ============================================
// Function: capture_P_W
// --------------------------------------------

void testbench::capture_P_W( ac_fixed<16, 4, true, AC_TRN, AC_SAT > P_W[1800])
{
   if (P_W_capture_count == wait_cnt)
      wait_on_input_required();
   if (_capture_P_W && !P_W_ignore)
   {
      int cur_iter = P_W_iteration_count;
      ++P_W_iteration_count;
      mgc_sysc_ver_array1D<ac_fixed<16, 4, true, AC_TRN, AC_SAT >,1800> P_W_tmp;
      int P_W_linear_idx = 0;
      for (int P_W_idx_0 = 0; P_W_idx_0 < 1800; ++P_W_idx_0)
         P_W_tmp[P_W_linear_idx++] = P_W[P_W_idx_0];
      ccs_P_W->put(P_W_tmp);
      ++P_W_capture_count;
      mc_testbench::process_wait_ctrl("P_W",P_W_wait_ctrl,ccs_wait_ctrl_P_W.operator->(),cur_iter,P_W_capture_count,0);
   }
   P_W_ignore = false;
}
// ============================================
// Function: capture_P_B
// --------------------------------------------

void testbench::capture_P_B( ac_fixed<16, 4, true, AC_TRN, AC_SAT > P_B[10])
{
   if (P_B_capture_count == wait_cnt)
      wait_on_input_required();
   if (_capture_P_B && !P_B_ignore)
   {
      int cur_iter = P_B_iteration_count;
      ++P_B_iteration_count;
      mgc_sysc_ver_array1D<ac_fixed<16, 4, true, AC_TRN, AC_SAT >,10> P_B_tmp;
      int P_B_linear_idx = 0;
      for (int P_B_idx_0 = 0; P_B_idx_0 < 10; ++P_B_idx_0)
         P_B_tmp[P_B_linear_idx++] = P_B[P_B_idx_0];
      ccs_P_B->put(P_B_tmp);
      ++P_B_capture_count;
      mc_testbench::process_wait_ctrl("P_B",P_B_wait_ctrl,ccs_wait_ctrl_P_B.operator->(),cur_iter,P_B_capture_count,0);
   }
   P_B_ignore = false;
}
// ============================================
// Function: capture_index
// --------------------------------------------

void testbench::capture_index( ac_int<4, false > index[1])
{
   if (_capture_index)
   {
      int cur_iter = index_iteration_count;
      ++index_iteration_count;
      mc_golden_info< mgc_sysc_ver_array1D<ac_int<4, false >,1>, ac_int<4, false > > index_tmp(index_ignore, false, index_iteration_count);
      index_tmp._data.mc_testbench_process_array_bounds("index",index_array_comp_first,index_array_comp_last,0,0);
      // BEGIN: testbench output_mask control for field_name index
      if ( index_use_mask ) {
         index_tmp._use_mask = true;
         index_tmp._mask = index_output_mask ;
      }
      // END: testbench output_mask control for field_name index
      int index_linear_idx = 0;
      for (int index_idx_0 = 0; index_idx_0 < 1; ++index_idx_0)
         index_tmp._data[index_linear_idx++] = index[index_idx_0];
      if (!index_skip) {
         index_golden.put(index_tmp);
         ++index_capture_count;
      } else {
         if (!index_skip_quiet || !index_skip_once) {
            std::ostringstream msg; msg.str("");
            msg << "index_skip=true for iteration=" << index_iteration_count << " @ " << sc_time_stamp();
            SC_REPORT_WARNING("User testbench", msg.str().c_str());
            index_skip_once = true;
         }
      }
      mc_testbench::process_wait_ctrl("index",index_wait_ctrl,ccs_wait_ctrl_index.operator->(),cur_iter,index_capture_count,0);
      index_use_mask = false;
   }
   index_ignore = false;
   index_skip = false;
}
// ============================================
// Function: wait_on_input_required
// --------------------------------------------

void testbench::wait_on_input_required()
{
   ++wait_cnt;
   wait(SC_ZERO_TIME); // get fifos a chance to update
   while (atleast_one_active_input) {
      if (_capture_image && ccs_image->used() == 0) return;
      if (_capture_F_1 && ccs_F_1->used() == 0) return;
      if (_capture_B_1 && ccs_B_1->used() == 0) return;
      if (_capture_F_2 && ccs_F_2->used() == 0) return;
      if (_capture_B_2 && ccs_B_2->used() == 0) return;
      if (_capture_F_3 && ccs_F_3->used() == 0) return;
      if (_capture_B_3 && ccs_B_3->used() == 0) return;
      if (_capture_P_W && ccs_P_W->used() == 0) return;
      if (_capture_P_B && ccs_P_B->used() == 0) return;
      that->cpp_testbench_active.write(false);
      wait(ccs_image->ok_to_put() | ccs_F_1->ok_to_put() | ccs_B_1->ok_to_put() | ccs_F_2->ok_to_put() | ccs_B_2->ok_to_put() | ccs_F_3->ok_to_put() | ccs_B_3->ok_to_put() | ccs_P_W->ok_to_put() | ccs_P_B->ok_to_put());
      that->cpp_testbench_active.write(true);
   }
}
// ============================================
// Function: capture_IN
// --------------------------------------------

void testbench::capture_IN( ac_fixed<16, 4, true, AC_TRN, AC_SAT > image[1728],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > F_1[1728],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > B_1[64],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > F_2[18432],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > B_2[32],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > F_3[5760],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > B_3[20],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > P_W[1800],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > P_B[10],  ac_int<4, false > index[1])
{
   that->capture_image(image);
   that->capture_F_1(F_1);
   that->capture_B_1(B_1);
   that->capture_F_2(F_2);
   that->capture_B_2(B_2);
   that->capture_F_3(F_3);
   that->capture_B_3(B_3);
   that->capture_P_W(P_W);
   that->capture_P_B(P_B);
}
// ============================================
// Function: capture_OUT
// --------------------------------------------

void testbench::capture_OUT( ac_fixed<16, 4, true, AC_TRN, AC_SAT > image[1728],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > F_1[1728],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > B_1[64],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > F_2[18432],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > B_2[32],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > F_3[5760],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > B_3[20],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > P_W[1800],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > P_B[10],  ac_int<4, false > index[1])
{
   that->capture_index(index);
}
// ============================================
// Function: exec_CNN_main_simple
// --------------------------------------------

void testbench::exec_CNN_main_simple( ac_fixed<16, 4, true, AC_TRN, AC_SAT > image[1728],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > F_1[1728],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > B_1[64],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > F_2[18432],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > B_2[32],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > F_3[5760],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > B_3[20],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > P_W[1800],  ac_fixed<16, 4, true, AC_TRN, AC_SAT > P_B[10],  ac_int<4, false > index[1])
{
   #ifndef CCS_SCVERIFY_USE_CCS_BLOCK
   that->cpp_testbench_active.write(true);
   capture_IN(image, F_1, B_1, F_2, B_2, F_3, B_3, P_W, P_B, index);
   CNN_main_simple(image, F_1, B_1, F_2, B_2, F_3, B_3, P_W, P_B, index);
   // throttle ac_channel based on number of calls to chan::size() or chan::empty() or chan::nb_read() (but not chan::available()) 
   if (1) {
      int cnt=0;
      if (cnt) std::cout << "mc_testbench.cpp: CONTINUES @ " << sc_time_stamp() << std::endl;
      if (cnt) that->cpp_testbench_active.write(true);
   }
   capture_OUT(image, F_1, B_1, F_2, B_2, F_3, B_3, P_W, P_B, index);
   #else
   #endif
}
// ============================================
// Function: start_of_simulation
// --------------------------------------------

void testbench::start_of_simulation()
{
   set_enable_stalls(false);
}
// ============================================
// Function: end_of_simulation
// --------------------------------------------

void testbench::end_of_simulation()
{
   if (!_checked_results) {
      SC_REPORT_INFO(name(), "Simulation ran into deadlock");
      check_results();
   }
}
// ============================================
// Function: check_results
// --------------------------------------------

void testbench::check_results()
{
   if (_checked_results) return;
   _checked_results = true;
   cout<<endl;
   cout<<"Checking results"<<endl;
   _failed = false;
   if (main_exit_code) _failed = true;
   int _num_outputs_checked = 0;
   std::ostringstream mctb_msg;
   
   if (!_capture_index) {
      cout<<"'index' - warning, output was optimized away"<<endl;
   } else {
      _num_outputs_checked++;
      _failed = _failed || index_comp->check_results(index_capture_count,index_skip_noerr);
   }
   cout<<endl;
   if (_num_outputs_checked == 0) {
      cout<<"Error: All outputs were optimized away. No output values were compared."<<endl;
      _failed = _failed || (_num_outputs_checked == 0);
   }
   if (main_exit_code) cout << "Error: C++ Testbench 'main()' returned a non-zero exit code ("<<main_exit_code<<"). Check your testbench." <<endl;
   mctb_msg.clear();
   if (_failed) mctb_msg << "Simulation FAILED";
   else         mctb_msg << "Simulation PASSED";
   mctb_msg << " @ " << sc_time_stamp();
   SC_REPORT_INFO(this->name(), mctb_msg.str().c_str());
}
// ============================================
// Function: failed
// --------------------------------------------

bool testbench::failed()
{
   return _failed;
}
// ---------------------------------------------------------------
// Process: SC_METHOD wait_for_end
// Static sensitivity: sensitive << clk.pos() << testbench_end_event;

void testbench::wait_for_end() {
   // If run() has not finished, we do nothing here
   if (!testbench_ended) return;
   // check for completed outputs
   if (index_comp->get_compare_count() < index_capture_count) {testbench_end_event.notify(1,SC_NS); return;}
   // If we made it here, all outputs have flushed. Check the results
   SC_REPORT_INFO(name(), "Simulation completed");
   check_results();
   sc_stop();
}
// ---------------------------------------------------------------
// Process: SC_THREAD run
// Static sensitivity: 

void testbench::run() {
   enable_idle_sync_mode = false;
   idle_sync_stable_cycles = 1;
   image_ignore = false;
   image_skip = false;
   image_skip_quiet = false;
   image_skip_once = false;
   image_skip_noerr = false;
   image_array_comp_first = -1;
   image_array_comp_last = -1;
   image_wait_ctrl.clear();
   image_capture_count = 0;
   image_iteration_count = 0;
   F_1_ignore = false;
   F_1_skip = false;
   F_1_skip_quiet = false;
   F_1_skip_once = false;
   F_1_skip_noerr = false;
   F_1_array_comp_first = -1;
   F_1_array_comp_last = -1;
   F_1_wait_ctrl.clear();
   F_1_capture_count = 0;
   F_1_iteration_count = 0;
   B_1_ignore = false;
   B_1_skip = false;
   B_1_skip_quiet = false;
   B_1_skip_once = false;
   B_1_skip_noerr = false;
   B_1_array_comp_first = -1;
   B_1_array_comp_last = -1;
   B_1_wait_ctrl.clear();
   B_1_capture_count = 0;
   B_1_iteration_count = 0;
   F_2_ignore = false;
   F_2_skip = false;
   F_2_skip_quiet = false;
   F_2_skip_once = false;
   F_2_skip_noerr = false;
   F_2_array_comp_first = -1;
   F_2_array_comp_last = -1;
   F_2_wait_ctrl.clear();
   F_2_capture_count = 0;
   F_2_iteration_count = 0;
   B_2_ignore = false;
   B_2_skip = false;
   B_2_skip_quiet = false;
   B_2_skip_once = false;
   B_2_skip_noerr = false;
   B_2_array_comp_first = -1;
   B_2_array_comp_last = -1;
   B_2_wait_ctrl.clear();
   B_2_capture_count = 0;
   B_2_iteration_count = 0;
   F_3_ignore = false;
   F_3_skip = false;
   F_3_skip_quiet = false;
   F_3_skip_once = false;
   F_3_skip_noerr = false;
   F_3_array_comp_first = -1;
   F_3_array_comp_last = -1;
   F_3_wait_ctrl.clear();
   F_3_capture_count = 0;
   F_3_iteration_count = 0;
   B_3_ignore = false;
   B_3_skip = false;
   B_3_skip_quiet = false;
   B_3_skip_once = false;
   B_3_skip_noerr = false;
   B_3_array_comp_first = -1;
   B_3_array_comp_last = -1;
   B_3_wait_ctrl.clear();
   B_3_capture_count = 0;
   B_3_iteration_count = 0;
   P_W_ignore = false;
   P_W_skip = false;
   P_W_skip_quiet = false;
   P_W_skip_once = false;
   P_W_skip_noerr = false;
   P_W_array_comp_first = -1;
   P_W_array_comp_last = -1;
   P_W_wait_ctrl.clear();
   P_W_capture_count = 0;
   P_W_iteration_count = 0;
   P_B_ignore = false;
   P_B_skip = false;
   P_B_skip_quiet = false;
   P_B_skip_once = false;
   P_B_skip_noerr = false;
   P_B_array_comp_first = -1;
   P_B_array_comp_last = -1;
   P_B_wait_ctrl.clear();
   P_B_capture_count = 0;
   P_B_iteration_count = 0;
   index_ignore = false;
   index_skip = false;
   index_skip_quiet = false;
   index_skip_once = false;
   index_skip_noerr = false;
   index_array_comp_first = -1;
   index_array_comp_last = -1;
   index_use_mask = false;
   index_output_mask = ~0;
   index_wait_ctrl.clear();
   index_capture_count = 0;
   index_iteration_count = 0;
   main_exit_code = main();
   cout<<"Info: Execution of user-supplied C++ testbench 'main()' has completed with exit code = " << main_exit_code << endl;
   cout<<endl;
   cout<<"Info: Collecting data completed"<<endl;
   cout<<"   captured "<<image_capture_count<<" values of image"<<endl;
   cout<<"   captured "<<F_1_capture_count<<" values of F_1"<<endl;
   cout<<"   captured "<<B_1_capture_count<<" values of B_1"<<endl;
   cout<<"   captured "<<F_2_capture_count<<" values of F_2"<<endl;
   cout<<"   captured "<<B_2_capture_count<<" values of B_2"<<endl;
   cout<<"   captured "<<F_3_capture_count<<" values of F_3"<<endl;
   cout<<"   captured "<<B_3_capture_count<<" values of B_3"<<endl;
   cout<<"   captured "<<P_W_capture_count<<" values of P_W"<<endl;
   cout<<"   captured "<<P_B_capture_count<<" values of P_B"<<endl;
   cout<<"   captured "<<index_capture_count<<" values of index"<<endl;
   testbench_ended = true;
   testbench_end_event.notify(SC_ZERO_TIME);
}
#ifdef CCS_SCVERIFY_USE_CCS_BLOCK
#include "ccs_block_macros.cpp"
#endif
