// ----------------------------------------------------------------------
//  HLS HDL:        SystemC Netlister
//  HLS Version:    2011a.62 Production Release
//  HLS Date:       Wed Nov 23 15:08:20 PST 2011
// 
//  Generated by:   xph3seiaba@cimeld20
//  Generated date: Fri Oct 24 14:34:36 2014
// ----------------------------------------------------------------------

// 


#define SC_USE_STD_STRING
#define SC_INCLUDE_DYNAMIC_PROCESSES
//Library is: mgc_hls
//Included from library 'mgc_hls'
#include <funcs.h>
//Included from library 'mgc_hls'
#include <mc_interface_channel.h>
//Included from library 'mgc_hls'
#include <mgc_ioport.h>
namespace HDL { 

#ifndef MC_PROCESS_STACK_SIZE
#define MC_PROCESS_STACK_SIZE 0x20000
#endif
// ------------------------------------------------------------------
//  Design Unit:    lab1_core_fsm
//  FSM Module
// ------------------------------------------------------------------



SC_MODULE(lab1_core_fsm) {
  public : sc_in< bool > clk;
  public : sc_in< sc_logic > rst;
  public : sc_out< sc_lv<2> > fsm_output;
  private: mc_out< sc_lv<2> > fsm_output_drv;

  // FSM State Type Declaration for lab1_core_fsm_1
  enum lab1_core_fsm_1_ST {st_main, st_main_1};

  sc_signal<lab1_core_fsm_1_ST > state_var;
  sc_signal<lab1_core_fsm_1_ST > state_var_NS;

  // Default Constants


  SC_HAS_PROCESS(lab1_core_fsm);
  public: lab1_core_fsm(const sc_module_name& module_name, const char * hdl_name=0)
      : sc_module(module_name)
    , clk("clk")
    , rst("rst")
    , fsm_output("fsm_output")
    , fsm_output_drv(fsm_output)
    , state_var("state_var")
    , state_var_NS("state_var_NS")
  {
    // Default Constant Signal Assignments

    SC_METHOD(lab1_core_fsm_1); 
    sensitive << state_var;
    SC_METHOD(lab1_core_fsm_1_REG); 
    sensitive << clk;
    SC_METHOD(lab1_core_fsm_conc); 
  }

private:
  void lab1_core_fsm_1() { 
    switch  (state_var) {
    case st_main: {
      fsm_output_drv = CONV_STD_LOGIC_VECTOR(1, 2);
      state_var_NS = st_main_1;
      break;
    }
    case st_main_1: {
      fsm_output_drv = CONV_STD_LOGIC_VECTOR(2, 2);
      state_var_NS = st_main;
      break;
    }
    }
  }
  void lab1_core_fsm_1_REG() { 
    if ( clk.posedge() ) {
      if ( ( mc_bool(rst.read())) ) {
        state_var = st_main;
      } else {
        state_var = state_var_NS;
      }
    }
  }

  void lab1_core_fsm_conc() {
  }

};
SC_MODULE_EXPORT(lab1_core_fsm);

// ------------------------------------------------------------------
//  Design Unit:    lab1_core
// ------------------------------------------------------------------



SC_MODULE(lab1_core) {
  public : sc_in< bool > clk;
  public : sc_in< sc_logic > rst;
  public : sc_in< sc_lv<256> > a_rsc_mgc_in_wire_d;
  public : sc_in< sc_lv<256> > b_rsc_mgc_in_wire_d;
  public : sc_out< sc_lv<256> > c_rsc_mgc_out_stdreg_d;
  private: mc_out< sc_lv<256> > c_rsc_mgc_out_stdreg_d_drv;

  // Interconnect Declarations
  sc_signal< sc_lv<2> > fsm_output;

  lab1_core_fsm *lab1_core_fsm_inst;
  // Default Constants


  SC_HAS_PROCESS(lab1_core);
  public: lab1_core(const sc_module_name& module_name, const char * hdl_name=0) :
      sc_module(module_name)
    , clk("clk")
    , rst("rst")
    , a_rsc_mgc_in_wire_d("a_rsc_mgc_in_wire_d")
    , b_rsc_mgc_in_wire_d("b_rsc_mgc_in_wire_d")
    , c_rsc_mgc_out_stdreg_d("c_rsc_mgc_out_stdreg_d")
    , c_rsc_mgc_out_stdreg_d_drv(c_rsc_mgc_out_stdreg_d)
    , fsm_output("fsm_output")
  {
    // Default Constant Signal Assignments

    lab1_core_fsm_inst = new lab1_core_fsm("lab1_core_fsm_inst");
    lab1_core_fsm_inst->clk(clk);
    lab1_core_fsm_inst->rst(rst);
    lab1_core_fsm_inst->fsm_output(fsm_output);

    SC_METHOD(lab1_core_conc); 
    sensitive << clk;
  }

private:
  void lab1_core_conc() {
    if (clk.posedge()) { 
      if (rst.read() == 1) {
        c_rsc_mgc_out_stdreg_d_drv = CONV_STD_LOGIC_VECTOR(mc_lv_sc("0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),
            256);
      } else {
        c_rsc_mgc_out_stdreg_d_drv = MUX_v(CONV_STD_LOGIC_VECTOR((c_rsc_mgc_out_stdreg_d_drv.read()
            , (CONV_STD_LOGIC_VECTOR((CONV_STD_LOGIC_VECTOR((CONV_STD_LOGIC_VECTOR((CONV_STD_LOGIC_VECTOR((sc_int<32>)(SIGNED((sc_lv<32>)a_rsc_mgc_in_wire_d.read().range(255,
            224)) + SIGNED((sc_lv<32>)b_rsc_mgc_in_wire_d.read().range(255, 224))),
            32) , CONV_STD_LOGIC_VECTOR((sc_int<32>)(SIGNED((sc_lv<32>)a_rsc_mgc_in_wire_d.read().range(223,
            192)) + SIGNED((sc_lv<32>)b_rsc_mgc_in_wire_d.read().range(223, 192))),
            32)), 64) , CONV_STD_LOGIC_VECTOR((CONV_STD_LOGIC_VECTOR((sc_int<32>)(SIGNED((sc_lv<32>)a_rsc_mgc_in_wire_d.read().range(191,
            160)) + SIGNED((sc_lv<32>)b_rsc_mgc_in_wire_d.read().range(191, 160))),
            32) , CONV_STD_LOGIC_VECTOR((sc_int<32>)(SIGNED((sc_lv<32>)a_rsc_mgc_in_wire_d.read().range(159,
            128)) + SIGNED((sc_lv<32>)b_rsc_mgc_in_wire_d.read().range(159, 128))),
            32)), 64)), 128) , CONV_STD_LOGIC_VECTOR((CONV_STD_LOGIC_VECTOR((CONV_STD_LOGIC_VECTOR((sc_int<32>)(SIGNED((sc_lv<32>)a_rsc_mgc_in_wire_d.read().range(127,
            96)) + SIGNED((sc_lv<32>)b_rsc_mgc_in_wire_d.read().range(127, 96))),
            32) , CONV_STD_LOGIC_VECTOR((sc_int<32>)(SIGNED((sc_lv<32>)a_rsc_mgc_in_wire_d.read().range(95,
            64)) + SIGNED((sc_lv<32>)b_rsc_mgc_in_wire_d.read().range(95, 64))),
            32)), 64) , CONV_STD_LOGIC_VECTOR((CONV_STD_LOGIC_VECTOR((sc_int<32>)(SIGNED((sc_lv<32>)a_rsc_mgc_in_wire_d.read().range(63,
            32)) + SIGNED((sc_lv<32>)b_rsc_mgc_in_wire_d.read().range(63, 32))),
            32) , CONV_STD_LOGIC_VECTOR((sc_int<32>)(SIGNED((sc_lv<32>)a_rsc_mgc_in_wire_d.read().range(31,
            0)) + SIGNED((sc_lv<32>)b_rsc_mgc_in_wire_d.read().range(31, 0))), 32)),
            64)), 128)), 256))), 512), fsm_output.read().bit(0));
      }
    }
  }

};
SC_MODULE_EXPORT(lab1_core);

// ------------------------------------------------------------------
//  Design Unit:    lab1
//  Generated from file(s):
//    2) $PROJECT_HOME/lab1.cpp
// ------------------------------------------------------------------



SC_MODULE(lab1) {
  public : sc_in< sc_lv<256> > a_rsc_z;
  public : sc_in< sc_lv<256> > b_rsc_z;
  public : sc_out< sc_lv<256> > c_rsc_z;
  private: mc_out< sc_lv<256> > c_rsc_z_drv;
  public : sc_in< bool > clk;
  public : sc_in< sc_logic > rst;

  // Interconnect Declarations
  sc_signal< sc_lv<256> > a_rsc_mgc_in_wire_d;
  sc_signal< sc_lv<256> > b_rsc_mgc_in_wire_d;
  sc_signal< sc_lv<256> > c_rsc_mgc_out_stdreg_d;

  mgc_in_wire</* rscid= */ 1, /* width= */ 256> *a_rsc_mgc_in_wire;
  mgc_in_wire</* rscid= */ 2, /* width= */ 256> *b_rsc_mgc_in_wire;
  mgc_out_stdreg</* rscid= */ 3, /* width= */ 256> *c_rsc_mgc_out_stdreg;
  lab1_core *lab1_core_inst;
  // Default Constants


  SC_HAS_PROCESS(lab1);
  public: lab1(const sc_module_name& module_name, const char * hdl_name=0) : sc_module(module_name)
    , a_rsc_z("a_rsc_z")
    , b_rsc_z("b_rsc_z")
    , c_rsc_z("c_rsc_z")
    , c_rsc_z_drv(c_rsc_z)
    , clk("clk")
    , rst("rst")
    , a_rsc_mgc_in_wire_d("a_rsc_mgc_in_wire_d")
    , b_rsc_mgc_in_wire_d("b_rsc_mgc_in_wire_d")
    , c_rsc_mgc_out_stdreg_d("c_rsc_mgc_out_stdreg_d")
  {
    // Default Constant Signal Assignments

    a_rsc_mgc_in_wire = new mgc_in_wire</* rscid= */ 1, /* width= */ 256>("a_rsc_mgc_in_wire");
    a_rsc_mgc_in_wire->d(a_rsc_mgc_in_wire_d);
    a_rsc_mgc_in_wire->z(a_rsc_z);

    b_rsc_mgc_in_wire = new mgc_in_wire</* rscid= */ 2, /* width= */ 256>("b_rsc_mgc_in_wire");
    b_rsc_mgc_in_wire->d(b_rsc_mgc_in_wire_d);
    b_rsc_mgc_in_wire->z(b_rsc_z);

    c_rsc_mgc_out_stdreg = new mgc_out_stdreg</* rscid= */ 3, /* width= */ 256>("c_rsc_mgc_out_stdreg");
    c_rsc_mgc_out_stdreg->d(c_rsc_mgc_out_stdreg_d);
    c_rsc_mgc_out_stdreg->z(c_rsc_z_drv);

    lab1_core_inst = new lab1_core("lab1_core_inst");
    lab1_core_inst->clk(clk);
    lab1_core_inst->rst(rst);
    lab1_core_inst->a_rsc_mgc_in_wire_d(a_rsc_mgc_in_wire_d);
    lab1_core_inst->b_rsc_mgc_in_wire_d(b_rsc_mgc_in_wire_d);
    lab1_core_inst->c_rsc_mgc_out_stdreg_d(c_rsc_mgc_out_stdreg_d);

    SC_METHOD(IDLE_CONC); 
  }

private:
  void IDLE_CONC() {
  }

};
SC_MODULE_EXPORT(lab1);

} 


